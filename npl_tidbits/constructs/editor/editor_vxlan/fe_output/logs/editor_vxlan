# 1 "npl/editor_vxlan.npl"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "npl/editor_vxlan.npl"
# 46 "npl/editor_vxlan.npl"
# 1 "npl/base_helper.npl" 1
# 39 "npl/base_helper.npl"
struct l2_t {
    fields {
        bit[48] macda;
        bit[48] macsa;
        bit[16] ethertype;
    }
}

struct ipv4_t {
    fields {
        bit[4] version;
        bit[4] hdr_len;
        bit[8] tos;
        bit[16] v4_length;
        bit[16] id;
        bit[3] flags;
        bit[13] frag_offset;
        bit[8] ttl;
        bit[8] protocol;
        bit[16] hdr_checksum;
        bit[32] sip;
        bit[32] dip;
        varbit[512] option;
    }
    header_length_exp : hdr_len*4;
}

struct udp_t {
    fields {
        bit[16] src_port;
        bit[16] dst_port;
        bit[16] udp_length;
        bit[16] checksum;
    }
}

struct vxlan_t {
    fields {
        bit[4] f_flag1;
        bit[1] i_flag;
        bit[3] f_flag2;
        bit[24] reserved1;
        bit[24] vn_id;
        bit[8] reserved2;
    }
}

struct group1_t {
    fields {
        l2_t l2;
    }
}

struct group2_t {
    fields {
        ipv4_t ipv4;
        udp_t udp;
        vxlan_t vxlan;
    }
}

struct ing_pkt_t {
    fields {
        group1_t group1;
        group2_t group2;
        group1_t group3;
        group2_t group4;
    }
}

struct egr_pkt_t {
    fields {
        group1_t group1;
        group2_t group2;
        group1_t group3;
        group2_t group4;
    }
}


packet ing_pkt_t ingress_pkt;
packet egr_pkt_t egress_pkt;



struct obj_bus_t {
    fields {
        bit[2] port_type_cfg;
        bit[7] port_num;
        bit[8] dst_modid;
        bit[7] dst_port;
    }
}


struct ccbi_t {
    fields {
        bit[128] l2_pbm;
        bit[128] l3_pbm;
    }
}

struct ccbe_t {
    fields {
        bit[7] dst_port;
    }
}

struct control_id_t {
    fields {
        bit[4] otpid_enable;
        bit ts_enable;
    }
}

struct time_bus_t {
    fields {
        bit[16] currenttime;
    }
}

struct egr_obj_bus_t {
    fields {
        bit[8] dst_modid;
        bit[7] dst_port;
        bit[7] ing_port;
        bit[16] ingress_timestamp;
    }
}

struct aux_bus_t {
    fields {
        bit [16] drop_vector;
    }
}

bus obj_bus_t obj_bus;
bus ccbi_t ccbi;
bus ccbe_t ccbe;
bus control_id_t control_id;
bus time_bus_t time_bus;
bus egr_obj_bus_t egr_obj_bus;
bus aux_bus_t egr_aux_bus;



special_function iarb {

    usage_mode_create(in const eindex,
               out bit[4] otpid_enable,
               out bit[1] ts_enable,
               out bit[7] port_num,
               out bit[2] port_type_cfg,
               out bit[16] currenttime
               );

    usage_mode_select(in bit[1] eindex);

}

special_function mmu {

    usage_mode_create(in const eindex,
               in bit[128] l2_pbm,
               in bit[128] l3_pbm,
               out bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}


special_function edb {

    usage_mode_create(in const eindex,
               in bit[16] drop_vector,
               in bit[8] dst_mod,
               in bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}

function base_assign_destination() {
    ccbi.l3_pbm = 0;
    ccbe.dst_port = 0;
    ccbi.l2_pbm = 0x2;
}

function base_egress() {
    egr_aux_bus.drop_vector = 0;
    egr_obj_bus.dst_modid = 0;
    egr_obj_bus.dst_port = ccbe.dst_port;
}
# 47 "npl/editor_vxlan.npl" 2
# 58 "npl/editor_vxlan.npl"
parser_node start {
    root_node : 1;
    next_node ethernet;
}


parser_node ethernet{
    extract_fields(ingress_pkt.group1.l2);
    switch (latest.ethertype) {
        0x0800 : next_node ipv4;
        default : next_node ingress;
    }
}


parser_node ipv4{
    extract_fields(ingress_pkt.group2.ipv4);
    switch (latest.protocol) {
        0x11 : next_node udp;
        default : next_node ingress;
    }
}


parser_node udp {
    extract_fields(ingress_pkt.group2.udp);
    switch(latest.dst_port) {
        4789 : next_node vxlan;
        default : next_node ingress;
    }
}


parser_node vxlan {
    extract_fields(ingress_pkt.group2.vxlan);
    next_node inner_l2;
}


parser_node inner_l2 {
    extract_fields(ingress_pkt.group3.l2);
    switch (latest.ethertype) {
        0x0800 : next_node inner_ipv4;
        default: next_node ingress;
    }
}


parser_node inner_ipv4 {
    extract_fields(ingress_pkt.group4.ipv4);
    next_node ingress;
}

parser_node ingress {
    end_node: 1;
}







function do_egress_pkt_modify()
{
    if (ingress_pkt.group2.vxlan._PRESENT) {

        print ("VxLAN packet, do decapsulation\n");


        egress_pkt.group1.l2 = ingress_pkt.group1.l2;
        egress_pkt.group2.ipv4 = ingress_pkt.group2.ipv4;
        egress_pkt.group2.udp = ingress_pkt.group2.udp;
        egress_pkt.group2.vxlan = ingress_pkt.group2.vxlan;
        egress_pkt.group3.l2 = ingress_pkt.group3.l2;
        egress_pkt.group4.ipv4 = ingress_pkt.group4.ipv4;


        delete_header(egress_pkt.group1.l2);
        delete_header(egress_pkt.group2.ipv4);
        delete_header(egress_pkt.group2.udp);
        delete_header(egress_pkt.group2.vxlan);

    } else {

        print ("Non-VxLAN packet, do VxLAN encapsulation\n");



        egress_pkt.group1.l2.macda = 0x0000000000bb;
        egress_pkt.group1.l2.macsa = 0x0000000000aa;
        egress_pkt.group1.l2.ethertype = 0x0800;

        egress_pkt.group2.ipv4.version = 0x4;
        egress_pkt.group2.ipv4.hdr_len = 0x5;
        egress_pkt.group2.ipv4.sip = 0x01010101;
        egress_pkt.group2.ipv4.dip = 0x02020202;
        egress_pkt.group2.ipv4.ttl = 0x40;
        egress_pkt.group2.ipv4.protocol = 0x11;

        egress_pkt.group2.udp.src_port = 0x1234;
        egress_pkt.group2.udp.dst_port = 4789;

        egress_pkt.group2.vxlan.f_flag1 = 0xf;
        egress_pkt.group2.vxlan.i_flag = 1;
        egress_pkt.group2.vxlan.f_flag2 = 0x7;
        egress_pkt.group2.vxlan.vn_id = 0xf;


        egress_pkt.group3.l2 = ingress_pkt.group1.l2;

        egress_pkt.group4.ipv4 = ingress_pkt.group2.ipv4;


        add_header (egress_pkt.group1.l2);
        add_header (egress_pkt.group2.ipv4);
        add_header (egress_pkt.group2.udp);
        add_header (egress_pkt.group2.vxlan);


        update_packet_length(egress_pkt.group2.ipv4.v4_length, 1, 0);
        update_packet_length(egress_pkt.group2.udp.udp_length, 0, 0);


         create_checksum(egress_pkt.group2.ipv4.hdr_checksum, {egress_pkt.group2.ipv4.version,
                         egress_pkt.group2.ipv4.hdr_len, egress_pkt.group2.ipv4.tos,
                         egress_pkt.group2.ipv4.v4_length, egress_pkt.group2.ipv4.id,
                         egress_pkt.group2.ipv4.flags, egress_pkt.group2.ipv4.frag_offset,
                         egress_pkt.group2.ipv4.ttl, egress_pkt.group2.ipv4.protocol,
                         egress_pkt.group2.ipv4.sip, egress_pkt.group2.ipv4.dip});

    }
}




program editor_vxlan {



    iarb.usage_mode_create( 0, control_id.otpid_enable, control_id.ts_enable, obj_bus.port_num, obj_bus.port_type_cfg, time_bus.currenttime ); iarb.execute();





    parse_begin(start);

    if (ingress_pkt.group2.vxlan._PRESENT) {
        print ("Ingress packet is a VxLAN packet. \n");
    } else {
        print ("Ingress packet is a non-VxLAN packet. \n");
    }


    base_assign_destination();
    mmu.usage_mode_create( 0, ccbi.l2_pbm, ccbi.l3_pbm, ccbe.dst_port ); mmu.execute();


    base_egress();



    do_egress_pkt_modify();



    edb.usage_mode_create( 0, egr_aux_bus.drop_vector, egr_obj_bus.dst_modid, egr_obj_bus.dst_port ); edb.execute();
}
