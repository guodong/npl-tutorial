# 1 "npl/data_types_and_parser.npl"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "npl/data_types_and_parser.npl"
# 32 "npl/data_types_and_parser.npl"
# 1 "npl/base_helper.npl" 1
# 38 "npl/base_helper.npl"
struct obj_bus_t {
    fields {
        bit[2] port_type_cfg;
        bit[7] port_num;
        bit[8] dst_modid;
        bit[7] dst_port;
    }
}


struct ccbi_t {
    fields {
        bit[128] l2_pbm;
        bit[128] l3_pbm;
    }
}

struct ccbe_t {
    fields {
        bit[7] dst_port;
    }
}

struct control_id_t {
    fields {
        bit[4] otpid_enable;
        bit ts_enable;
    }
}

struct time_bus_t {
    fields {
        bit[16] currenttime;
    }
}

struct egr_obj_bus_t {
    fields {
        bit[8] dst_modid;
        bit[7] dst_port;
        bit[7] ing_port;
        bit[16] ingress_timestamp;
    }
}

struct aux_bus_t {
    fields {
        bit [16] drop_vector;
    }
}

bus obj_bus_t obj_bus;
bus ccbi_t ccbi;
bus ccbe_t ccbe;
bus control_id_t control_id;
bus time_bus_t time_bus;
bus egr_obj_bus_t egr_obj_bus;
bus aux_bus_t egr_aux_bus;



special_function iarb {

    usage_mode_create(in const eindex,
               out bit[4] otpid_enable,
               out bit[1] ts_enable,
               out bit[7] port_num,
               out bit[2] port_type_cfg,
               out bit[16] currenttime
               );

    usage_mode_select(in bit[1] eindex);

}

special_function mmu {

    usage_mode_create(in const eindex,
               in bit[128] l2_pbm,
               in bit[128] l3_pbm,
               out bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}


special_function edb {

    usage_mode_create(in const eindex,
               in bit[16] drop_vector,
               in bit[8] dst_mod,
               in bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}

function base_assign_destination() {
    ccbi.l3_pbm = 0;
    ccbe.dst_port = 0;
    ccbi.l2_pbm = 1 << obj_bus.port_num;
}

function base_egress() {
    egr_aux_bus.drop_vector = 0;
    egr_obj_bus.dst_modid = 0;
    egr_obj_bus.dst_port = obj_bus.port_num;
}
# 33 "npl/data_types_and_parser.npl" 2
# 51 "npl/data_types_and_parser.npl"
struct l2_t {
    fields {
        bit[48] macda;
        bit[48] macsa;
        bit[16] ethertype;
    }
}
# 67 "npl/data_types_and_parser.npl"
struct vlan_t {
    fields {
        bit[3] pcp;
        bit cfi;
        bit[12] vid;
        bit[16] ethertype;
    }
}
# 87 "npl/data_types_and_parser.npl"
struct l2_hdr_grp_t {
    fields {
        l2_t l2;
        vlan_t outer_tag;
        vlan_t inner_tag;
    }
}
# 106 "npl/data_types_and_parser.npl"
struct ipv4_t {
    fields {
        bit[4] version;
        bit[4] hdr_len;
        bit[8] tos;
        bit[16] v4_length;
        bit[16] id;
        bit[3] flags;
        bit[13] frag_offset;
        bit[8] ttl;
        bit[8] protocol;
        bit[16] hdr_checksum;
        bit[32] sip;
        bit[32] dip;
        varbit[512] option;
    }
    header_length_exp : hdr_len*4;
}

struct l3_hdr_grp_t {
    fields {
        ipv4_t ipv4;
    }
}
# 139 "npl/data_types_and_parser.npl"
struct ingress_pkt_t {
    fields {
        l2_hdr_grp_t l2_hdr;
        l3_hdr_grp_t l3_hdr;
    }
}




packet ingress_pkt_t ingress_pkt;

parser_node start {
    root_node : 1;
    next_node ethernet;
}

parser_node ethernet {





  extract_fields(ingress_pkt.l2_hdr.l2);
  switch(latest.ethertype) {
    0x88A8:
      next_node otag;

    0x8100:
      next_node itag;

    0x0800:
      next_node ipv4;

    default :
      next_node ingress;
  }
}

parser_node otag {
  extract_fields(ingress_pkt.l2_hdr.outer_tag);
  switch(latest.ethertype) {
     0x8100:
      next_node itag;

    0x0800 :
      next_node ipv4;

    default :
      next_node ingress;
  }
}

parser_node itag {
  extract_fields(ingress_pkt.l2_hdr.inner_tag);





  if (latest.ethertype == 0x0800) {
      next_node ipv4;
  } else {
    next_node ingress;
  }
}

parser_node ipv4 {
    extract_fields(ingress_pkt.l3_hdr.ipv4);
    next_node ingress;
}

parser_node ingress {

    end_node : 1;
}




program data_types_and_parser {



    iarb.usage_mode_create( 0, control_id.otpid_enable, control_id.ts_enable, obj_bus.port_num, obj_bus.port_type_cfg, time_bus.currenttime ); iarb.execute();






    parse_begin(start);

    print("Src Mac: 0x%x\n", ingress_pkt.l2_hdr.l2.macsa);
    print("Dst Mac: 0x%x\n", ingress_pkt.l2_hdr.l2.macda);
# 242 "npl/data_types_and_parser.npl"
    if (ingress_pkt.l2_hdr.outer_tag._PRESENT && ingress_pkt.l2_hdr.inner_tag._PRESENT) {
      print("Packet is double tagged\n");
      print("Outer VlanId is %d\n",ingress_pkt.l2_hdr.outer_tag.vid);
      print("Inner VlanId is %d\n",ingress_pkt.l2_hdr.inner_tag.vid);
    }

    if (ingress_pkt.l2_hdr.outer_tag._PRESENT && !ingress_pkt.l2_hdr.inner_tag._PRESENT) {
      print("Packet is single outer tagged\n");
      print("Outer VlanId is %d\n",ingress_pkt.l2_hdr.outer_tag.vid);
    }

    if (!ingress_pkt.l2_hdr.outer_tag._PRESENT && ingress_pkt.l2_hdr.inner_tag._PRESENT) {
      print("Packet is single inner tagged\n");
      print("Inner VlanId is %d\n",ingress_pkt.l2_hdr.inner_tag.vid);
    }

    if (!ingress_pkt.l2_hdr.outer_tag._PRESENT && !ingress_pkt.l2_hdr.inner_tag._PRESENT) {
      print("Packet is un-tagged\n");
    }

    if (ingress_pkt.l3_hdr.ipv4._PRESENT) {

      print("Source ip address is 0X%x\n", ingress_pkt.l3_hdr.ipv4.sip);

      print("Destination ip address is 0X%x\n", ingress_pkt.l3_hdr.ipv4.dip);
      if (ingress_pkt.l3_hdr.ipv4.option != 0) {
        print("This is a packet with IP options\n");
      }
    }


    base_assign_destination();
    mmu.usage_mode_create( 0, ccbi.l2_pbm, ccbi.l3_pbm, ccbe.dst_port ); mmu.execute();



    base_egress();



    edb.usage_mode_create( 0, egr_aux_bus.drop_vector, egr_obj_bus.dst_modid, egr_obj_bus.dst_port ); edb.execute();
}
