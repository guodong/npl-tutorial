# 1 "npl/strength_vid.npl"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "npl/strength_vid.npl"
# 76 "npl/strength_vid.npl"
# 1 "npl/base_helper.npl" 1
# 39 "npl/base_helper.npl"
struct l2_t {
    fields {
        bit[48] macda;
        bit[48] macsa;
        bit[16] ethertype;
    }
}

struct vlan_t {
    fields {
        bit[3] pcp;
        bit[1] cfi;
        bit[12] vid;
        bit[16] ethertype;
    }
}

struct snap_llc_t {
    fields {
        bit[48] snap_llc;
    }
}

struct snap_t {
    fields {
        bit[48] oui;
        bit[16] ethertype;
    }
}

struct llc_t {
    fields {
        bit[24] llc;
    }
}

struct group1_t {
    fields {
        l2_t l2;
        snap_llc_t snap_or_llc;
        snap_t snap;
        llc_t llc;
        vlan_t vlan_tag;
    }
}

struct ing_pkt_t {
    fields {
        group1_t group1;
    }
}

packet ing_pkt_t ingress_pkt;


struct obj_bus_t {
    fields {
        bit[2] port_type_cfg;
        bit[7] port_num;
        bit[8] dst_modid;
        bit[7] dst_port;
    }
}


struct ccbi_t {
    fields {
        bit[128] l2_pbm;
        bit[128] l3_pbm;
    }
}

struct ccbe_t {
    fields {
        bit[7] dst_port;
    }
}

struct control_id_t {
    fields {
        bit[4] otpid_enable;
        bit ts_enable;
    }
}

struct time_bus_t {
    fields {
        bit[16] currenttime;
    }
}

struct egr_obj_bus_t {
    fields {
        bit[8] dst_modid;
        bit[7] dst_port;
        bit[7] ing_port;
        bit[16] ingress_timestamp;
    }
}

struct aux_bus_t {
    fields {
        bit [16] drop_vector;
    }
}

bus obj_bus_t obj_bus;
bus ccbi_t ccbi;
bus ccbe_t ccbe;
bus control_id_t control_id;
bus time_bus_t time_bus;
bus egr_obj_bus_t egr_obj_bus;
bus aux_bus_t egr_aux_bus;



special_function iarb {

    usage_mode_create(in const eindex,
               out bit[4] otpid_enable,
               out bit[1] ts_enable,
               out bit[7] port_num,
               out bit[2] port_type_cfg,
               out bit[16] currenttime
               );

    usage_mode_select(in bit[1] eindex);

}

special_function mmu {

    usage_mode_create(in const eindex,
               in bit[128] l2_pbm,
               in bit[128] l3_pbm,
               out bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}


special_function edb {

    usage_mode_create(in const eindex,
               in bit[16] drop_vector,
               in bit[8] dst_mod,
               in bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}

function base_assign_destination() {
    ccbi.l3_pbm = 0;
    ccbe.dst_port = 0;
    ccbi.l2_pbm = 0x2;
}

function base_egress() {
    egr_aux_bus.drop_vector = 0;
    egr_obj_bus.dst_modid = 0;
    egr_obj_bus.dst_port = ccbe.dst_port;
}
# 77 "npl/strength_vid.npl" 2
# 97 "npl/strength_vid.npl"
struct local_bus_t {
    fields {
        bit[1] pkt_protocol;
        bit[12] vid;
    }
}

bus local_bus_t local_bus;




parser_node start {
    root_node : 1;
    next_node ethernet;
}


parser_node ethernet{
    extract_fields(ingress_pkt.group1.l2);
    switch (latest.ethertype) {
        0x8100 : next_node vlan_tag;
        0x0000 mask 0xFC00: next_node snap_or_llc;
        0x0400 mask 0xFE00: next_node snap_or_llc;
        default : next_node ingress;
    }
}


parser_node vlan_tag {
    extract_fields(ingress_pkt.group1.vlan_tag);
    switch(latest.ethertype) {
        0x0000 mask 0xFC00: next_node snap_or_llc;
        0x0400 mask 0xFE00: next_node snap_or_llc;
        default : next_node ingress;
    }
}


parser_node snap_or_llc {
    extract_fields(ingress_pkt.group1.snap_or_llc);
    switch (latest.snap_llc) {
        0xAAAA03000000 : next_node snap;
        default : next_node llc;
    }
}


parser_node snap {
    extract_fields(ingress_pkt.group1.snap);
    next_node ingress;
}


parser_node llc {
    extract_fields(ingress_pkt.group1.llc);
    next_node ingress;
}

parser_node ingress {
    end_node : 1;
}





struct vlan_strength_t {
    fields {
        bit[4] vlan_strength;
    }
}





strength vlan_strength_t vlan_strength_profile_table;





logical_table port_table {

    table_type : index;
    minsize : 128;
    maxsize : 128;

    keys {
        bit[7] port_num;
    }

    fields {
        bit[12] default_vid;
    }

    key_construct() {
        port_num = obj_bus.port_num;
    }

    fields_assign() {
        if(_LOOKUP0 == 1)
        {

            use_strength (vlan_strength_profile_table, 1);
        }
    }

}






logical_table vlan_protocol_table {

    table_type : index;
    minsize : 2;
    maxsize : 2;

    keys {
        bit pkt_protocol;
    }

    fields {
        bit[12] vid;
    }

    key_construct() {
        pkt_protocol = local_bus.pkt_protocol;
    }


    fields_assign() {
        if(_LOOKUP0 == 1)
        {

            use_strength (vlan_strength_profile_table, 2);
        }
    }

}







function do_pkt_protocol_assignment () {

    if (ingress_pkt.group1.snap._PRESENT) {
        local_bus.pkt_protocol = 0x0;
        print ("Ingress packet is a SNAP packet.\n");
    } else if (ingress_pkt.group1.llc._PRESENT){
        local_bus.pkt_protocol = 0x1;
        print ("Ingress packet is a LLC packet.\n");
    } else {
        print ("Ingress packet is a ETHERII packet.\n");
    }
}





program strength_vlan {



    iarb.usage_mode_create( 0, control_id.otpid_enable, control_id.ts_enable, obj_bus.port_num, obj_bus.port_type_cfg, time_bus.currenttime ); iarb.execute();





    parse_begin(start);

    if (ingress_pkt.group1.vlan_tag._PRESENT) {

        print ("Ingress packet is a outer tagged packet, vlan id = %d\n", ingress_pkt.group1.vlan_tag.vid);

    } else {

        print ("Ingress packet is an untagged packet.\n");


        port_table.lookup(0);


        do_pkt_protocol_assignment();





        if ( ingress_pkt.group1.snap._PRESENT ||
               ingress_pkt.group1.llc._PRESENT) {

            vlan_protocol_table.lookup(0);
        }
# 309 "npl/strength_vid.npl"
         strength_resolve( local_bus.vid,
                NULL,
                { port_table._LOOKUP0, NULL, vlan_strength_profile_table.vlan_strength, port_table.default_vid},
                { vlan_protocol_table._LOOKUP0, NULL, vlan_strength_profile_table.vlan_strength, vlan_protocol_table.vid} );



        print ("Vlan assigment is done, vid = %d \n", local_bus.vid);
    }


    base_assign_destination();
    mmu.usage_mode_create( 0, ccbi.l2_pbm, ccbi.l3_pbm, ccbe.dst_port ); mmu.execute();


    base_egress();




    edb.usage_mode_create( 0, egr_aux_bus.drop_vector, egr_obj_bus.dst_modid, egr_obj_bus.dst_port ); edb.execute();
}
