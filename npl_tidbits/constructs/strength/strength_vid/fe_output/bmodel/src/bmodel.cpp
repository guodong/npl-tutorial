/*
 * $Copyright: (c) 2018 Broadcom Corp.
 * All Rights Reserved.$
 * File:     bmodel.cpp
 * Purpose:  NPL Behavior Modeling Source Code
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from:
 * npl/strength_vid.npl
 * Edits to this file will be lost when it is regenerated.
 *
 */


/*
 * includes
 */

#include "bmodel.h"


/*
 * bmodel constructor
 */

_BModel::_BModel() { 


    /*
     * bus instantiations
     */

    obj_bus = new obj_bus_t;
    ccbi = new ccbi_t;
    ccbe = new ccbe_t;
    control_id = new control_id_t;
    time_bus = new time_bus_t;
    egr_obj_bus = new egr_obj_bus_t;
    egr_aux_bus = new aux_bus_t;
    local_bus = new local_bus_t;


    /*
     * packet instantiations
     */

    ingress_pkt = new ing_pkt_t;


    /*
     * table instantiations
     */

    /* table class instances */
    port_table = new port_table_tab_t;
    vlan_protocol_table = new vlan_protocol_table_tab_t;
    vlan_strength_profile_table = new vlan_strength_profile_table_tab_t;
    sfc_mmu_profile = new sfc_mmu_profile_tab_t;
    sfc_edb_profile = new sfc_edb_profile_tab_t;
    sfc_iarb_profile = new sfc_iarb_profile_tab_t;

    /* sfc bookkeeping table */
    sfc_mmu_profile__bk = new sfc_bk_t(2, 3);
    sfc_edb_profile__bk = new sfc_bk_t(2, 3);
    sfc_iarb_profile__bk = new sfc_bk_t(2, 5);

    /* initialize SF tables */
    _AUTO_sf_tbl_init();

}


/*
 * bmodel disstructor
 */

_BModel::~_BModel() { 
    /* buses */
    delete obj_bus;
    delete ccbi;
    delete ccbe;
    delete control_id;
    delete time_bus;
    delete egr_obj_bus;
    delete egr_aux_bus;
    delete local_bus;
    /* packets */
    delete ingress_pkt;
    /* table classes */
    delete port_table;
    delete vlan_protocol_table;
    delete vlan_strength_profile_table;
    delete sfc_mmu_profile;
    delete sfc_edb_profile;
    delete sfc_iarb_profile;
    /* sfc bookkeeping tables */
    delete sfc_mmu_profile__bk;
    delete sfc_edb_profile__bk;
    delete sfc_iarb_profile__bk;

}


/*
 * ing init function
 */

void _BModel::_AUTO_ing_init(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    /* reset random generator */
    srand(time(NULL));

    /* reset hdr_ptr */
    hdr_ptr = 0;
    pn_func = 0;

    /* clear ing_pkt_drp_info */
    ing_pkt_drp_info.first_opcode = 0;
    ing_pkt_drp_info.max_opcode = 0;
    ing_pkt_drp_info.max_strn = 0;
    ing_pkt_drp_info.pp_drop = 0;
    ing_pkt_drp_info.hard_pp_drop = 0;
    /* clear ing_pkt_trc_info */
    ing_pkt_trc_info.bitmap = 0;
    /* clear ing_pkt_cnt_info */
    ing_pkt_cnt_info.bitmap = 0;
    in_ing_main = 1;

    /* initialize ing packets */
    ingress_pkt->set_resetval();
    match_id = &ingress_pkt->_match_id;

    /* initialize ing buses */
    if (bus_reset_0) {
        /* reset bus to 0 */
        control_id->set_resetval();
        obj_bus->set_resetval();
        time_bus->set_resetval();
        local_bus->set_resetval();
        ccbe->set_resetval();
        ccbi->set_resetval();
    } else {
        /* reset bus to random values */
        control_id->set_randval();
        obj_bus->set_randval();
        time_bus->set_randval();
        local_bus->set_randval();
        ccbe->set_randval();
        ccbi->set_randval();
    }

    /* initialize ing table pointers */
    port_table_entry_LOOKUP0 = NULL;
    vlan_protocol_table_entry_LOOKUP0 = NULL;
    /* initialize ing strength table pointers */
    vlan_strength_profile_table_entry = NULL;
    /* initialize ing special function table pointers */
    sfc_iarb_profile_entry = NULL;
    sfc_mmu_profile_entry = NULL;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * egr init function
 */

void _BModel::_AUTO_egr_init(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    /* clear egr_pkt_drp_info */
    egr_pkt_drp_info.first_opcode = 0;
    egr_pkt_drp_info.max_opcode = 0;
    egr_pkt_drp_info.max_strn = 0;
    egr_pkt_drp_info.pp_drop = 0;
    egr_pkt_drp_info.hard_pp_drop = 0;
    /* clear egr_pkt_trc_info */
    egr_pkt_trc_info.bitmap = 0;
    /* clear egr_pkt_cnt_info */
    egr_pkt_cnt_info.bitmap = 0;
    in_ing_main = 0;

    /* initialize egr packets */

    /* initialize egr only buses */
    if (bus_reset_0) {
        /* reset bus to 0 */
        egr_aux_bus->set_resetval();
        egr_obj_bus->set_resetval();
    } else {
        /* reset bus to random values */
        egr_aux_bus->set_randval();
        egr_obj_bus->set_randval();
    }

    /* initialize egr table pointers */
    /* initialize egr strength table pointers */
    /* initialize egr special function table pointers */
    sfc_mmu_profile_entry = NULL;
    sfc_edb_profile_entry = NULL;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * strength resolution functions
 */

void _BModel::_AUTO_str_res_local_bus_vid(void) {
    _2bits vlan_strength_profile_table_index;
    _4bits fld_str[3] = {0,0,0};
    _12bits fld_str_val[3] = {0,0,0};
    _4bits tmp_max_str;
    _12bits tmp_fld_val;
    int idx;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif

    /* load strength values */
    fld_str[0] = 0;
    fld_str_val[0] = local_bus->vid;
    if (port_table_entry_LOOKUP0 != NULL) {
        vlan_strength_profile_table_index = 1;
        vlan_strength_profile_table_entry = vlan_strength_profile_table->lookup(0, &vlan_strength_profile_table_index);
        fld_str[1] = vlan_strength_profile_table_entry->vlan_strength;
        fld_str_val[1] = port_table_entry_LOOKUP0->default_vid;
    }
    if (vlan_protocol_table_entry_LOOKUP0 != NULL) {
        vlan_strength_profile_table_index = 2;
        vlan_strength_profile_table_entry = vlan_strength_profile_table->lookup(0, &vlan_strength_profile_table_index);
        fld_str[2] = vlan_strength_profile_table_entry->vlan_strength;
        fld_str_val[2] = vlan_protocol_table_entry_LOOKUP0->vid;
    }

    /* determine field value based on strength */
    tmp_max_str = fld_str[0];
    tmp_fld_val = fld_str_val[0];
    for (idx=1; idx<3; idx++) {
        if (fld_str[idx] > tmp_max_str) {
            tmp_max_str = fld_str[idx];
            tmp_fld_val = fld_str_val[idx];
        }
    }

    if (tmp_max_str > 0) {
        local_bus->set_vid(tmp_fld_val, 11, 0);
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * table key functions
 */

void _BModel::_AUTO_KEY_GEN_port_table(_1bit lookup, _7bits *port_num) {
    _1bit _LOOKUP0 = lookup==0?1:0;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    *port_num = obj_bus->port_num;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_KEY_GEN_vlan_protocol_table(_1bit lookup, _1bit *pkt_protocol) {
    _1bit _LOOKUP0 = lookup==0?1:0;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    *pkt_protocol = local_bus->pkt_protocol;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * table action functions
 */

void _BModel::_AUTO_ACTION_port_table(port_table_entry_t *entry) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: entry->_LOOKUP0: 0x%s;  line: %d", entry->_LOOKUP0.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if ((entry->_LOOKUP0 == 1)) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        /*use_strength();*/
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_ACTION_vlan_protocol_table(vlan_protocol_table_entry_t *entry) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: entry->_LOOKUP0: 0x%s;  line: %d", entry->_LOOKUP0.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if ((entry->_LOOKUP0 == 1)) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        /*use_strength();*/
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * parse node functions
 */

void _BModel::_AUTO_PARSER_NODE_start(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    /* root_node */
    _AUTO_PARSER_NODE_ethernet();
    return;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_PARSER_NODE_ethernet(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    if (ingress_pkt->group1->l2->extract_fields(ing_pkt, &hdr_ptr, &pkt_len)!=0) {
#ifndef NO_CONSOLE_OUTPUT
        bmi_log->error("ERROR: %s(): extract_fields() error", __FUNCTION__);
#endif
        return;
    }
    ingress_pkt->group1->l2->_PRESENT = 1;
    ingress_pkt->group1->l2->_PRESENT_CUR = 1;
    update_mid__ingress_pkt__group1__l2();
#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: ingress_pkt->group1->l2->ethertype: 0x%s;  line: %d", ingress_pkt->group1->l2->ethertype.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if ((ingress_pkt->group1->l2->ethertype == 0x8100)) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        _AUTO_PARSER_NODE_vlan_tag();
        return;
    } else {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: ingress_pkt->group1->l2->ethertype: 0x%s;  line: %d", ingress_pkt->group1->l2->ethertype.to_string(SC_HEX_US, false).c_str(), __LINE__);
        }
#endif
        if (((ingress_pkt->group1->l2->ethertype & 0xFC00) == (0x0000 & 0xFC00))) {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
            _AUTO_PARSER_NODE_snap_or_llc();
            return;
        } else {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: ingress_pkt->group1->l2->ethertype: 0x%s;  line: %d", ingress_pkt->group1->l2->ethertype.to_string(SC_HEX_US, false).c_str(), __LINE__);
            }
#endif
            if (((ingress_pkt->group1->l2->ethertype & 0xFE00) == (0x0400 & 0xFE00))) {
#ifndef NO_CONSOLE_OUTPUT
                if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                    bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
                }
#endif
                _AUTO_PARSER_NODE_snap_or_llc();
                return;
            } else {
#ifndef NO_CONSOLE_OUTPUT
                if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                    bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
                }
#endif
                _AUTO_PARSER_NODE_ingress();
                return;
            }
        }
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_PARSER_NODE_vlan_tag(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    if (ingress_pkt->group1->vlan_tag->extract_fields(ing_pkt, &hdr_ptr, &pkt_len)!=0) {
#ifndef NO_CONSOLE_OUTPUT
        bmi_log->error("ERROR: %s(): extract_fields() error", __FUNCTION__);
#endif
        return;
    }
    ingress_pkt->group1->vlan_tag->_PRESENT = 1;
    ingress_pkt->group1->vlan_tag->_PRESENT_CUR = 1;
    update_mid__ingress_pkt__group1__vlan_tag();
#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: ingress_pkt->group1->vlan_tag->ethertype: 0x%s;  line: %d", ingress_pkt->group1->vlan_tag->ethertype.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if (((ingress_pkt->group1->vlan_tag->ethertype & 0xFC00) == (0x0000 & 0xFC00))) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        _AUTO_PARSER_NODE_snap_or_llc();
        return;
    } else {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: ingress_pkt->group1->vlan_tag->ethertype: 0x%s;  line: %d", ingress_pkt->group1->vlan_tag->ethertype.to_string(SC_HEX_US, false).c_str(), __LINE__);
        }
#endif
        if (((ingress_pkt->group1->vlan_tag->ethertype & 0xFE00) == (0x0400 & 0xFE00))) {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
            _AUTO_PARSER_NODE_snap_or_llc();
            return;
        } else {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
            _AUTO_PARSER_NODE_ingress();
            return;
        }
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_PARSER_NODE_snap_or_llc(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    if (ingress_pkt->group1->snap_or_llc->extract_fields(ing_pkt, &hdr_ptr, &pkt_len)!=0) {
#ifndef NO_CONSOLE_OUTPUT
        bmi_log->error("ERROR: %s(): extract_fields() error", __FUNCTION__);
#endif
        return;
    }
    ingress_pkt->group1->snap_or_llc->_PRESENT = 1;
    ingress_pkt->group1->snap_or_llc->_PRESENT_CUR = 1;
    update_mid__ingress_pkt__group1__snap_or_llc();
#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: ingress_pkt->group1->snap_or_llc->snap_llc: 0x%s;  line: %d", ingress_pkt->group1->snap_or_llc->snap_llc.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if ((ingress_pkt->group1->snap_or_llc->snap_llc == 0xAAAA03000000)) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        _AUTO_PARSER_NODE_snap();
        return;
    } else {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        _AUTO_PARSER_NODE_llc();
        return;
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_PARSER_NODE_snap(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    if (ingress_pkt->group1->snap->extract_fields(ing_pkt, &hdr_ptr, &pkt_len)!=0) {
#ifndef NO_CONSOLE_OUTPUT
        bmi_log->error("ERROR: %s(): extract_fields() error", __FUNCTION__);
#endif
        return;
    }
    ingress_pkt->group1->snap->_PRESENT = 1;
    ingress_pkt->group1->snap->_PRESENT_CUR = 1;
    update_mid__ingress_pkt__group1__snap();
    _AUTO_PARSER_NODE_ingress();
    return;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_PARSER_NODE_llc(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    if (ingress_pkt->group1->llc->extract_fields(ing_pkt, &hdr_ptr, &pkt_len)!=0) {
#ifndef NO_CONSOLE_OUTPUT
        bmi_log->error("ERROR: %s(): extract_fields() error", __FUNCTION__);
#endif
        return;
    }
    ingress_pkt->group1->llc->_PRESENT = 1;
    ingress_pkt->group1->llc->_PRESENT_CUR = 1;
    update_mid__ingress_pkt__group1__llc();
    _AUTO_PARSER_NODE_ingress();
    return;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::_AUTO_PARSER_NODE_ingress(void) {

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    /* end_node - parsing done */
    pn_func = 0;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * varbit functions
 */


/*
 * functions
 */

void _BModel::base_assign_destination(void) {
    _128bits set_bits_128;
    _7bits set_bits_7;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    set_bits_128 = 0; 
    ccbi->set_l3_pbm(set_bits_128, 127, 0);
    set_bits_7 = 0; 
    ccbe->set_dst_port(set_bits_7, 6, 0);
    set_bits_128 = 0x2; 
    ccbi->set_l2_pbm(set_bits_128, 127, 0);

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::base_egress(void) {
    _16bits set_bits_16;
    _8bits set_bits_8;
    _7bits set_bits_7;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
    set_bits_16 = 0; 
    egr_aux_bus->set_drop_vector(set_bits_16, 15, 0);
    set_bits_8 = 0; 
    egr_obj_bus->set_dst_modid(set_bits_8, 7, 0);
    set_bits_7 = ccbe->dst_port; 
    egr_obj_bus->set_dst_port(set_bits_7, 6, 0);

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}


void _BModel::do_pkt_protocol_assignment(void) {
    _1bit set_bit_1;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif
#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: ingress_pkt->group1->snap->_PRESENT: 0x%s;  line: %d", ingress_pkt->group1->snap->_PRESENT.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if ((ingress_pkt->group1->snap->_PRESENT != 0)) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        set_bit_1 = 0x0; 
        local_bus->set_pkt_protocol(set_bit_1, 0, 0);
        printf("Ingress packet is a SNAP packet.\n");
    } else {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: ingress_pkt->group1->llc->_PRESENT: 0x%s;  line: %d", ingress_pkt->group1->llc->_PRESENT.to_string(SC_HEX_US, false).c_str(), __LINE__);
        }
#endif
        if ((ingress_pkt->group1->llc->_PRESENT != 0)) {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
            set_bit_1 = 0x1; 
            local_bus->set_pkt_protocol(set_bit_1, 0, 0);
            printf("Ingress packet is a LLC packet.\n");
        } else {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
            printf("Ingress packet is a ETHERII packet.\n");
        }
    }

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * ingress main
 */

void _BModel::ing_main(void) {
    _1bit    tbl_key_pkt_protocol_1;
    _7bits    tbl_key_port_num_7;
    _1bit sfc_idx_bits_1;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif

#ifndef NO_CONSOLE_OUTPUT
    bmi_log->normal("bm_debug_lvl = %d", bm_debug_lvl);

    bmi_log->normal("###### Starting Ingress Pipeline Processing ######");
#endif

    /* initialize packets and buses */
    _AUTO_ing_init();

    sfc_idx_bits_1 = 0;
    sfc_iarb_profile_entry = sfc_iarb_profile->lookup(0, &sfc_idx_bits_1);
    sfc_iarb_profile__sfc_call((void*)sfc_iarb_profile_entry, sfc_idx_bits_1);
    _AUTO_PARSER_NODE_start();
#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
        bmi_log->normal("BM_TRACE: ingress_pkt->group1->vlan_tag->_PRESENT: 0x%s;  line: %d", ingress_pkt->group1->vlan_tag->_PRESENT.to_string(SC_HEX_US, false).c_str(), __LINE__);
    }
#endif
    if ((ingress_pkt->group1->vlan_tag->_PRESENT != 0)) {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        printf("Ingress packet is a outer tagged packet, vlan id = %d\n", (int)ingress_pkt->group1->vlan_tag->vid);
    } else {
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
        }
#endif
        printf("Ingress packet is an untagged packet.\n");
        _AUTO_KEY_GEN_port_table(0, &tbl_key_port_num_7);
        port_table_entry_LOOKUP0 = port_table->lookup(0, &tbl_key_port_num_7);
        _AUTO_ACTION_port_table(port_table_entry_LOOKUP0);
        do_pkt_protocol_assignment();
#ifndef NO_CONSOLE_OUTPUT
        if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
            bmi_log->normal("BM_TRACE: ingress_pkt->group1->llc->_PRESENT: 0x%s;  line: %d", ingress_pkt->group1->llc->_PRESENT.to_string(SC_HEX_US, false).c_str(), __LINE__);
            bmi_log->normal("BM_TRACE: ingress_pkt->group1->snap->_PRESENT: 0x%s;  line: %d", ingress_pkt->group1->snap->_PRESENT.to_string(SC_HEX_US, false).c_str(), __LINE__);
        }
#endif
        if ((ingress_pkt->group1->snap->_PRESENT || ingress_pkt->group1->llc->_PRESENT)) {
#ifndef NO_CONSOLE_OUTPUT
            if (bm_debug_lvl >= BM_DEBUG_LVL_TRACE) {
                bmi_log->normal("BM_TRACE: %s()  line: %d", __FUNCTION__, __LINE__);
            }
#endif
            _AUTO_KEY_GEN_vlan_protocol_table(0, &tbl_key_pkt_protocol_1);
            vlan_protocol_table_entry_LOOKUP0 = vlan_protocol_table->lookup(0, &tbl_key_pkt_protocol_1);
            _AUTO_ACTION_vlan_protocol_table(vlan_protocol_table_entry_LOOKUP0);
        }
        _AUTO_str_res_local_bus_vid();
        printf("Vlan assigment is done, vid = %d \n", (int)local_bus->vid);
    }
    base_assign_destination();
    sfc_idx_bits_1 = 0;
    sfc_mmu_profile_entry = sfc_mmu_profile->lookup(0, &sfc_idx_bits_1);
    sfc_mmu_profile__sfc_call((void*)sfc_mmu_profile_entry, sfc_idx_bits_1);

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}



/*
 * egress main
 */

void _BModel::egr_main(void) {
    _1bit sfc_idx_bits_1;

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() enter", __FUNCTION__);
    }
#endif

#ifndef NO_CONSOLE_OUTPUT
    bmi_log->normal("##### Starting Egress Pipeline Processing #####");
#endif

    /* initialize egr buses */
    _AUTO_egr_init();

    sfc_idx_bits_1 = 0;
    sfc_mmu_profile_entry = sfc_mmu_profile->lookup(0, &sfc_idx_bits_1);
    sfc_mmu_profile__sfc_call((void*)sfc_mmu_profile_entry, sfc_idx_bits_1);
    base_egress();
    sfc_idx_bits_1 = 0;
    sfc_edb_profile_entry = sfc_edb_profile->lookup(0, &sfc_idx_bits_1);
    sfc_edb_profile__sfc_call((void*)sfc_edb_profile_entry, sfc_idx_bits_1);

#ifndef NO_CONSOLE_OUTPUT
    if (bm_debug_lvl >= BM_DEBUG_LVL_DEBUG_NZ) {
        bmi_log->normal("BM_DEBUG: %s() exit", __FUNCTION__);
    }
#endif
}

