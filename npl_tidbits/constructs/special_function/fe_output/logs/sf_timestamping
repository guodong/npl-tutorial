# 1 "npl/sf_timestamping.npl"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "npl/sf_timestamping.npl"
# 38 "npl/sf_timestamping.npl"
# 1 "npl/base_helper.npl" 1
# 38 "npl/base_helper.npl"
parser_node start {
    root_node : 1;
}

parser_node ingress {
    end_node : 1;
}

struct obj_bus_t {
    fields {
        bit[2] port_type_cfg;
        bit[7] port_num;
        bit[8] dst_modid;
        bit[7] dst_port;
    }
}


struct ccbi_t {
    fields {
        bit[128] l2_pbm;
        bit[128] l3_pbm;
    }
}

struct ccbe_t {
    fields {
        bit[7] dst_port;
    }
}

struct control_id_t {
    fields {
        bit[4] otpid_enable;
        bit ts_enable;
    }
}

struct time_bus_t {
    fields {
        bit[16] currenttime;
    }
}

struct egr_obj_bus_t {
    fields {
        bit[8] dst_modid;
        bit[7] dst_port;
        bit[7] ing_port;
        bit[16] ingress_timestamp;
    }
}

struct aux_bus_t {
    fields {
        bit [16] drop_vector;
    }
}

bus obj_bus_t obj_bus;
bus ccbi_t ccbi;
bus ccbe_t ccbe;
bus control_id_t control_id;
bus time_bus_t time_bus;
bus egr_obj_bus_t egr_obj_bus;
bus aux_bus_t egr_aux_bus;



special_function iarb {

    usage_mode_create(in const eindex,
               out bit[4] otpid_enable,
               out bit[1] ts_enable,
               out bit[7] port_num,
               out bit[2] port_type_cfg,
               out bit[16] currenttime
               );

    usage_mode_select(in bit[1] eindex);

}

special_function mmu {

    usage_mode_create(in const eindex,
               in bit[128] l2_pbm,
               in bit[128] l3_pbm,
               out bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}


special_function edb {

    usage_mode_create(in const eindex,
               in bit[16] drop_vector,
               in bit[8] dst_mod,
               in bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}

function base_assign_destination() {
    ccbi.l3_pbm = 0;
    ccbe.dst_port = 0;
    ccbi.l2_pbm = 0x2;
}

function base_egress() {
    egr_aux_bus.drop_vector = 0;
    egr_obj_bus.dst_modid = 0;
    egr_obj_bus.dst_port = ccbe.dst_port;
}
# 39 "npl/sf_timestamping.npl" 2




logical_register ts_ctrl {
    fields {
        bit[1] enable = 0x1;
    }
}
# 57 "npl/sf_timestamping.npl"
special_function timestamping {
    usage_mode_create(in const index,
              in bit ts_enable,
              out bit ts_valid,
              out bit[32] ts_val_sec,
              out bit[32] ts_val_nsec
              );
    usage_mode_select(in bit index);
}




struct local_bus_t {
    fields{
        bit ts_enable;
        bit ts_valid;
        bit[32] ts_val_sec;
        bit[32] ts_val_nsec;
    }
}

bus local_bus_t local_bus;




function ts_enable() {
    local_bus.ts_enable = ts_ctrl.enable;
}







program sf_timestamping {





    iarb.usage_mode_create( 0, control_id.otpid_enable, control_id.ts_enable, obj_bus.port_num, obj_bus.port_type_cfg, time_bus.currenttime ); iarb.execute();
# 109 "npl/sf_timestamping.npl"
    ts_enable();


    timestamping.usage_mode_create( 0,
            local_bus.ts_enable,
            local_bus.ts_valid,
            local_bus.ts_val_sec,
            local_bus.ts_val_nsec
            );


    timestamping.execute();

    if (local_bus.ts_valid) {

        print ("Timestamp is valid: ts_val_sec = %d sec, ts_val_nsec = %d ns\n", local_bus.ts_val_sec, local_bus.ts_val_nsec);
    }



    base_assign_destination();
    mmu.usage_mode_create( 0, ccbi.l2_pbm, ccbi.l3_pbm, ccbe.dst_port ); mmu.execute();


    base_egress();




    edb.usage_mode_create( 0, egr_aux_bus.drop_vector, egr_obj_bus.dst_modid, egr_obj_bus.dst_port ); edb.execute();
}
